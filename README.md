# АиСД-2, 2023, КДЗ-3
## Степанов А, БПИ212

### Вводная

[Задание](https://disk.yandex.ru/i/Gkjgb9kLMloKJA)

Мною реализованы 2 КМП алгоритма и Наивный Алгоритм, дополнительный алгоритм я реализовывать не стал.

При этом я проанализировал как время работы алгоритмов, так и количество посимвольных сравнений, производимое во время их выполнения.

### Запуск проекта 

Через терминал:

```zsh
cd <Путь к директории проекта>

python generate.py # генерация входных данных

mkdir build # Создание папки для скомпилированного проекта

cd build && # Компиляция и запуск
cmake -DCMAKE_MAKE_PROGRAM=ninja -DCMAKE_CXX_COMPILER=clang++ -G Ninja -S .. -B . &&
cmake --build . --target all &&
./main &&
cd ..

python make_graphs.py ./data/output # создание графиков
```

Для запуска таким образом на ПК должны быть установлены **cmake**, **ninja** и **clang++**.

Однако можно запустить проект и с помощью установленного IDE, например: CLion.

### Отчёт

**Фактические сложности выполнения данных алгоритмов:**

**Naive Algorithm -- в худшем случае = O(n * m), в лучшем = O(n)**

**KMP - в худшем случае = O(n + m), в лучшем = O(n)**

*Где n - длина строки, а m - длина подстроки.*

- Из графиков времени выполнения алгоритма от длины искомой  подстроки:

Для [бинарного исходного текста длинной 10000 символов](/data/results/bin_text_10000/):

> Результаты для поиска подстроки без символов и с символами подстановки примерно одинаковы (однако время работы алгоритмов во втором случае в среднем на 10^5 наносекунд больше, чем в первом):
> 
> Изначально время работы обоих КМП алгоритмов незначительно отличается, однако затем оно линейно растёт, с большим коэффициентом для КМП, использующего уточнённые грани. Наивный алгоритм же начинает со значительно более высоким временем работы, которое затем линейно снижается и оказывается несколько меньше такового у КМП с уточнёнными гранями при размере подстроки большей 2800 символов.

Для [бинарного исходного текста длинной 100000 символов](/data/results/bin_text_100000/):

> Результаты для поиска подстроки без символов и с символами подстановки снова примерно одинаковы (однако время работы алгоритмов во втором случае в среднем на 10^6 наносекунд больше, чем в первом):
>
> Изначально время работы обоих КМП алгоритмов незначительно отличается, после чего оно очень сильно колеблется (при небольшом линейном росте у обоих), что сильно затрудняет его сравнение. Однако мне кажется, что для подстроки с символами подстановки КМП, использующий уточнённые грани, работает в среднем лучше, а для подстроки без символов подстановки -- наоборот. Наивный алгоритм начинает со **значительно** более высоким временем работы, которое затем также сильно колеблется и незначительно снижается.

Для [квадричного исходного текста длинной 10000 символов](/data/results/quad_text_10000/):

> В целом ситуация идентична таковой для бинарного текста такой же длины. Разница заключается в том, что начальное время работы для квадричного файла заметно ниже, коэффициенты линейного роста / снижения времени работы алгоритмов напротив -- несколько выше.

Для [квадричного исходного текста длинной 100000 символов](/data/results/quad_text_100000/):

> В целом ситуация идентична таковой для бинарного текста такой же длины. Разница заключается в том, что начальное время работы для квадричного файла заметно ниже, а время работы алгоритмов КМП для подстрок без и с символами подстановки соотносится наоборот.

### - Итого: 

> Полученные графики подтверждают утверждение о времени работы алгоритмов. Так как в полученных измерениях n = const, время работы изменяется линейно относительно m (где n - длина строки, m - длина подстроки) для текстов длинной 10000 символов и изменяется очень рвано для текста длинной 100000 символов (так как в этом случае n много больше m).
> 
>  В среднем КМП алгоритмы работают на порядок быстрее наивного алгоритма (1 * m + n против n * m + 0; где n - const, m - переменная). Однако при поиске подстроки относительно близкой по размеру к самой строке (при том, что строка состоит из в целом случайных символов; т.е. не созданной намеренно для достижения худшего случая) скорость работы наивного алгоритма стремится к лучшему случаю и даже превосходит таковую у КМП.
>
> При этом на сложных данных КМП, использующий уточнённые грани, работает несколько лучше стандартного КМП; хотя на полученных результатах это не совсем заметно -- я думаю, что для более реливантных графиков нужно проверять тексты на более сложных алфавитах. 

- Из графиков количества посимвольных сравнений при выполнения алгоритма от длины искомой  подстроки:

#### Мне кажется, что логичнее было бы анализировать количество элементарных операций, однако в [задании](https://disk.yandex.ru/i/Gkjgb9kLMloKJA) указано именно количество посимвольных сравнений (смотри 7й слайд).

Для [бинарного исходного текста длинной 10000 символов](/data/results/bin_text_10000/):

> Изначально количества посимвольных сравнений обоих КМП алгоритмов незначительно отличается, однако затем оно линейно растёт, с бОльшим коэффициентом для КМП, использующего уточнённые грани.
>
> Результаты для поиска подстроки без символов и с символами подстановки визуально похожи (однако количество посимвольных сравнений во втором случае в среднем в 2 раза больше, чем в первом).
>
> Наивный алгоритм же начинает со значительно меньшим количеством посимвольных сравнений относительно КМП в 1м случае и несколько большим во 2м, которое затем линейно снижается.
> 

Для [бинарного исходного текста длинной 100000 символов](/data/results/bin_text_100000/):

> Изначально количество посимвольных сравнений у КМП, использующего уточнённые грани заметно ниже, однако затем оно линейно растёт, с бОльшим коэффициентом для КМП, использующего уточнённые грани.
>
> Результаты для поиска подстроки без символов и с символами подстановки визуально похожи (однако количество посимвольных сравнений во втором случае в среднем в 2 раза больше у КМП и в 4-5 раза больше у Наивного Алгоритма, чем в первом).
>
> Наивный алгоритм же начинает со значительно меньшим количеством посимвольных сравнений относительно КМП в 1м случае и заметно большим во 2м, которое затем линейно снижается (с малым коэффициентом в первом случае, и с коэффициентом практически обратным коэффициенту роста КМП во втором).

Для [квадричного исходного текста длинной 10000 символов](/data/results/quad_text_10000/):

> Изначально количество посимвольных сравнений у КМП одинаково, однако затем оно линейно растёт, с бОльшим коэффициентом, чем у стандартного КМП.
>
> Результаты для поиска подстроки без символов и с символами подстановки визуально практически одинаковы (однако количество посимвольных сравнений во втором случае в среднем в 2-3 раза больше, чем в первом).
>
> Наивный алгоритм начинает со значительно меньшим количеством посимвольных сравнений относительно КМП в обоих случаях, которое затем линейно снижается (с малым коэффициентом в обоих случаях, во втором он несколько выше).

Для [квадричного исходного текста длинной 100000 символов](/data/results/quad_text_100000/):

> Для поиска подстроки без символов подстановки изначальное количество посимвольных сравнений у КМП одинаково, однако затем оно линейно растёт, с бОльшим коэффициентом для КМП, использующего уточнённые грани.
>
> Для поиска подстроки с символами подстановки изначальное количество посимвольных сравнений у стандартного КМП заметно выше, чеи у КМП, использующего уточнённые грани, затем оно линейно растёт, с совсем немного бОльшим коэффициентом для КМП, использующего уточнённые грани.
>
> Наивный алгоритм начинает с очень значительно меньшим количеством посимвольных сравнений относительно КМП в обоих случаях, которое затем остаётся практически стабильным.
> 
> Количество посимвольных сравнений во втором случае в среднем в 2-3 раза больше, чем в первом.

### - Итого: 

Полученные результаты вполне ожидаемы: КМП в отличие от Наивного Алгоритма проводит предварительный анализ, из-за чего количество посимвольных сравнений у них выше и притом квадратично зависит от размера входного текста. Соответственно чем больше исходный текст, тем более несоразмерно выше количество посимвольных сравнений у КМП относительно Наивного Алгоритма (При этом время работы КМП в среднем лучше, так как Наивный Алгоритм производит заметно больше других элементарных операций).

При этом если на менее сложных входных данных у стандартного КМП показатели лучше, чем у КМП, использующего уточнённые грани, то затем второй показывает лучшие результаты благодаря улучшенному предварительному анализу текста (т.е. уже непосредственно в процессе поиска подстроки второй КМП производит меньше посимвольных сравнений,чем первый).

### Карта проекта

#### [Основная директория](/)

>  Main файл проекта, запускающий процесс анализа работы всех исходных алгоритмов: [main.cpp](/main.cpp)
> 
>  Python скрипт, генерирующий входные данные: [generate.py](/generate.py)
> 
>  Python скрипт, генерирующий графики на основе полученных выходных данных [make_graphs.py](/make_graphs.py)

#### --> [data](/data/)

> Входные файлы: [texts](/data/texts)
>
> Выходные данные: [output](/data/output/)
>
> Графики, иллюстрирующие выходные данные: [results](/data/results/)
>
>> Графики отсортированы по папкам, соответствующим файлам со входными данными

#### --> [for_time_measure](/for_time_measure/)

> Содержит алгоритмы поиска подстрок без подсчёта производимых операций сравнений строк.

> Алгоритмы для поиска подстрок без символов подстановки: [normal](/for_time_measure/normal/)
>
> Алгоритмы для поиска подстрок с символами подстановки: [with_substitution](/for_time_measure/with_substitution/)

#### --> [for_comp_count_measure](/for_comp_count_measure/)

> Содержит алгоритмы поиска подстрок с подсчётом производимых операций сравнений строк.

> Алгоритмы для поиска подстрок без символов подстановки: [normal](/for_comp_count_measure/normal/)
>
> Алгоритмы для поиска подстрок с символами подстановки: [with_substitution](/for_comp_count_measure/with_substitution/)

#### --> [checker](/checker/)

> Содержит функции предназначенные для измерения времени работу функции / количества сравнений строк, производимых в ней.

#### --> [task_execution](/task_execution/)

> Содержит функции предназначенные для получения времени работы / количества сравнений строк, производимых в ней на некоторых входных данных и записи полученных данных в файл.